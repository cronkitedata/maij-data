---
title: "Filter, arrange, mutate prelab"
author: "YOUR NAME HERE"
format: 
  html: 
    theme: cosmos
    embed-resources:  true
    toc: true
    code-tools: true
    df-print: paged
---

This prelab goes along with [Verbs in depth Part 1](https://cronkitedata.github.io/djtextbook/r-verb-filter.html) and [Verbs in Depth part 2: Mutate](https://cronkitedata.github.io/djtextbook/r-verb-mutate.html) . You should follow along with the explanations and details in the textbook as you walk through this prelab.

## Load data 

You can examine in the Environment tab or by previewing the table, or by "glimpsing" it here. It's up to you.

```{r}
#| label: setup

library(tidyverse)
library(janitor)
library(lubridate)



```

```{r}

ppp_orig <- readRDS ( 
               url ( 
                 "https://cronkitedata.s3.amazonaws.com/rdata/ppp_az_loans.RDS"
                 )
               )


```

## Select 

Run this code

```{r}

ppp_small <- 
   ppp_orig |> 
  select (borrower_name, borrower_address, borrower_city,
          project_county, date_approved, amount, 
          forgiveness_amount)


glimpse(ppp_small)

```

**Describe, in your own words, what you just did:**

## Arrange 

What will the following code do?

```{r}

ppp_small |>
  arrange ( date_approved, desc(amount) )


```

## Simple filter examples

In the code chunks below, replace the "\_\_\_\_\_" blanks with whatever you would need to finish the code chunk. Try to get it so that you can run each chunk without errors.

1.  A list of borrowers from Flagstaff

```{r}

ppp_small |> 
  _____ ( borrower_city ___  "Flagstaff") 

```

2.  A list of borrowers from Flagstaff and Sedona

```{r}

ppp_small |> 
  filter ( borrower_city == "Flagstaff" ______  borrower_city == "Sedona") 

```

3.  Using the %in% operator, a list from Flagstaff, Sedona and Bisbee:

```{r}

ppp_small |> 
  filter ( borrower_city _____  
           c(________, ________, ________)
           )



```

4.  Borrowers from Flagstaff and Sedona whose loan was under \$100,000 . Sort it by the date approved.

```{r}

ppp_small |>
  filter ( 
           (borrower_city == "Flagstaff" | borrower_city == "Sedona") & 
            amount ___ _____ 
  ) |>
  ______  (date_approved)



```

5.  Why does this filter result in NO loans?

```{r}

ppp_small |> 
  filter (project_county == "Cochise County")


```

Fix the code above so that it gives you all of the loans in Cochise County

## Inexact matches with str_like()

Fill in the blank to find all loans on North Scottsdale street, road, etc.

```{r}

ppp_small |> 
  filter ( str_like ( borrower_address, 
                      "______________" ) ) |> 
  arrange ( borrower_address)



```

The wildcard probably picked up a few addresses you didn't intend to keep -- that's ok for now. Give one example of a mistake, and explain why it happened. You may have to page through several pages before you see any mistakes. (You won't see any if you just copied and pasted from the textbook!)


Filter the data so that it shows you all rows that are missing any information in the `forgiveness_amount` column: 

```{r}

ppp_small |>
  _______ ( _______ (forgiveness_amount ))



```



## Thoughts on filters

Write out three things you want to remember about `select`, `arrange` and `filter`:

1.  
2.  
3.  

Write out up to three things that you'd like to have clarified about `select`, `arrange` and `filter`

1.  
2.  
3.  

## Mutate 


Describe in your own words what this code chunk does: 

```{r}

ppp_orig |>
  mutate ( amt_diff =  forgiveness_amount-amount, 
           amt_pct_diff = amt_diff / amount  * 100 ) |>                   
  select ( borrower_name, borrower_city, amount, forgiveness_amount) |>   
  head(5).                                                                


```


To fix the missing data, we'll turn everything that is missing into zero (we know that that is the correct thing to do in this case.) . Fill in the blank to make that happen: 

```{r}

ppp_forgiven_fixed <- 
  ppp_orig |> 
  mutate ( forgiveness_amount = replace_na ( __________________, 0 ))




```


This compares the amount forgiven with the average and median amount for the entire state. We have eliminated the missing values in the forgiven amount, so we don't have to worry about them anymore. Run this code and examine the output: 

```{r}

ppp_forgiven_fixed |> 
  mutate ( avg_forgiven = mean(forgiveness_amount), 
           median_forgiven = median(forgiveness_amount)) |> 
  select (borrower_name, forgiveness_amount, avg_forgiven, median_forgiven ) |> 
  head()



```


### Categorizing text using conditional statements


First, try this simple conversion to create a category of "small" versus "large" loan. I added a new function called `sample_n()`, which lets you take a random sample of your data rather than look at it from the top or bottom.  : 

```{r}

ppp_orig |>
   mutate ( large_small = if_else (
                               amount >= 50000, 
                               "Large", 
                               "Small" 
                         )
   ) |>
   select ( borrower_name, amount, large_small  ) |>
   sample_n (100)


```

This is a more complicated example. Fill in the blank to fix this statement: 


```{r}

ppp_category_indiv <- 
  ppp_forgiven_fixed |>
  mutate ( is_individual = 
              if_else ( ______________ %in% 
                          c(
                            "Independent Contractors", 
                            "Sole Proprietorship", 
                            "Self-Employed Individuals", 
                            "Single Member LLC"
                            ), 
                    "Individual", 
                    "Organization"
                    ) 
  )  






```


* Why do you use the `%in%` operator and the `c()` function in this phrase? 



Try looking at a sample of the items to see whether it worked. 


```{r}

ppp_category_indiv |>
   select ( is_individual, business_type, amount) |>
   sample_n ( 100 )




```


Fill in the code below to create a new object (data frame) called `ppp_category_nonprofit` that uses the `str_like()` function to distinguish non-profit organizations "